//! Run asynchronous code in the context of a `tracing-forest` subscriber.
//! 
//! This module provides useful abstractions for executing async code:
//! [`worker_task`] for `main` functions, and [`capture`] for unit tests.
//! 
//! # Nonblocking log processing with `worker_task`
//! 
//! `tracing-forest` collects trace data into trees, and can sometimes
//! produce large trees that need to be processed. To avoid blocking the main
//! task in these cases, a common strategy is to send this data to a worker
//! task for formatting and writing.
//! 
//! The [`worker_task`] function provides this behavior as a first-class feature of this
//! crate, and handles the configuration, initialization, and graceful shutdown
//! of a subscriber with an associated worker task for formatting and writing.
//! 
//! ## Examples
//! 
//! ```
//! use tracing::{info, info_span};
//! 
//! #[tokio::main]
//! async fn main() {
//!     tracing_forest::worker_task()
//!         .build()
//!         .on(async {
//!             info!("Hello, world!");
//!
//!             info_span!("my_span").in_scope(|| {
//!                 info!("Relevant information");
//!             })
//!         })
//!         .await;
//! }
//! ```
//! Produces the output:
//! ```log
//! INFO     ＿ [info]: Hello, world!
//! INFO     my_span [ 26.0µs | 100.000% ]
//! INFO     ┕━ ＿ [info]: Relevant information
//! ```
//! 
//! For full configuration options, see the [`LayerBuilder`] documentation.
//! 
//! # Inspecting trace data in unit tests with `capture`
//! 
//! The [`capture`] function offers the ability to programmatically inspect log
//! trees generated by `tracing-forest`. It is the unit testing analog of
//! [`worker_task`], except it returns `Vec<Tree>` after the future is completed,
//! which can be then be inspected.
//! 
//! ## Examples
//! 
//! ```
//! use tracing_forest::tree::{Tree, Event, Span};
//! use tracing::{info, info_span};
//! 
//! #[tokio::main]
//! async fn main() -> Result<(), Box<dyn std::error::Error>> {
//!     let logs: Vec<Tree> = tracing_forest::capture()
//!         .build()
//!         .on(async {
//!             info!("Hello, world!");
//!
//!             info_span!("my_span").in_scope(|| {
//!                 info!("Relevant information");
//!             })
//!         })
//!         .await;
//!     
//!     // There is one event and one span at the root level
//!     assert!(logs.len() == 2);
//!     
//!     // Inspect the first event
//!     let hello_world: &Event = logs[0].event()?;
//!     assert!(hello_world.message() == Some("Hello, world!"));
//!
//!     // Inspect the span
//!     let my_span: &Span = logs[1].span()?;
//!     assert!(my_span.name() == "my_span");
//! 
//!     // Only the `info` event is recorded
//!     assert!(my_span.children().len() == 1);
//! 
//!     let relevant_info: &Event = my_span.children()[0].event()?;
//! 
//!     assert!(relevant_info.message() == Some("Relevant information"));
//! 
//!     Ok(())
//! }
//! ```
//! 
//! Additional options for tree inspection can be found in the
//! [`tree` module-level documentation](crate::tree)
//! 
//! For full configuration options, see the [`LayerBuilder`] documentation.
use crate::layer::ForestLayer;
use crate::printer::{Printer, StdoutPrinter};
use crate::tree::Tree;
use crate::fail;
use crate::tag::{TagParser, NoTag};
use crate::processor::{Processor, WithFallback, ProcessReport};
use crate::sealed::Sealed;
use std::future::Future;
use tokio::sync::mpsc::{self, UnboundedReceiver, UnboundedSender};
use tokio::sync::oneshot;
use tracing::Subscriber;
use tracing_subscriber::Registry;
use tracing_subscriber::layer::{Layer, Layered};

/// Returns a [`LayerBuilder`] that will send log trees to a processing task.
/// 
/// See the [module-level documentation][nonblocking-processing] for more details.
/// 
/// # Note
/// 
/// The [`worker_task`] function defaults to setting the global subscriber, which is required
/// to detect logs in multithreading scenarios, but prevents setting other [`Subscriber`]s
/// globally afterwards. This can be disabled via the [`set_global`] method.
/// 
/// [nonblocking-processing]: crate::builder#nonblocking-log-processing-with-worker_task
/// [`set_global`]: LayerBuilder::set_global
pub fn worker_task() -> LayerBuilder<TreeSender, Process<StdoutPrinter>, NoTag> {
    let (sender_processor, receiver) = mpsc::unbounded_channel();
    let receiver_processor = Process(Printer::default());

    LayerBuilder {
        sender_processor: TreeSender(sender_processor),
        receiver_kind: receiver_processor,
        receiver,
        tag: NoTag,
        is_global: false,
    }
}

/// Returns a [`LayerBuilder`] that will store log trees for later processing.
/// 
/// See the [module-level documentation][inspecting-trace-data] for more details.
/// 
/// # Note
/// 
/// The [`capture`] function defaults to not setting the global subscriber, which
/// allows multiple unit tests in the same file, but prevents trace data from other
/// threads to be collected. This can be enabled via the [`set_global`] method.
/// 
/// [inspecting-trace-data]: crate::builder#inspecting-trace-data-in-unit-tests-with-capture
/// [`set_global`]: LayerBuilder::set_global
pub fn capture() -> LayerBuilder<TreeSender, Capture, NoTag> {
    let (sender_processor, receiver) = mpsc::unbounded_channel();

    LayerBuilder {
        sender_processor: TreeSender(sender_processor),
        receiver_kind: Capture(()),
        receiver,
        tag: NoTag,
        is_global: false,
    }
}


/// Return type of [`worker_task`] and [`capture`].
/// 
/// # Configuring a `Runtime`
/// 
/// `LayerBuilder` follows the [builder pattern][builder] to configure a [`Runtime`].
/// 
/// Configuration options include:
/// * Setting the [tag][set_tag].
/// * Installing [globally][set_global].
/// * Configuring the [internal sender][map_sender] with fallbacks.
/// * Configuring the [processor][map_receiver] in the worker task.
/// 
/// To finish the `Runtime`, call the [`build`] method to compose the configured
/// `ForestLayer` onto a [`Registry`]. Alternatively, the [`build_with`] method
/// can be used construct an arbitrary `Subscriber` from the configured `ForestLayer`,
/// which is used in the returned `Runtime`.
/// 
/// [builder]: https://rust-lang.github.io/api-guidelines/type-safety.html#builders-enable-construction-of-complex-values-c-builder
/// [set_tag]: LayerBuilder::set_tag
/// [set_global]: LayerBuilder::set_global
/// [map_sender]: LayerBuilder::map_sender
/// [map_receiver]: LayerBuilder::map_receiver
/// [`build`]: LayerBuilder::build
/// [`build_with`]: LayerBuilder::build_with
pub struct LayerBuilder<Tx, Rx, T> {
    sender_processor: Tx,
    receiver_kind: Rx,
    receiver: UnboundedReceiver<Tree>,
    tag: T,
    is_global: bool,
}

/// A marker type indicating that trace data should be captured for later use.
pub struct Capture(());

/// A marker type indicating that trace data should be processed.
pub struct Process<P>(P);

/// The [`Processor`] used within a `tracing-forest` subscriber for sending logs
/// to a processing task.
#[derive(Debug)]
pub struct TreeSender(UnboundedSender<Tree>);

impl Processor for TreeSender {
    fn process(&self, tree: Tree) -> Result<(), ProcessReport> {
        self.0.process(tree)
    }
}

#[doc(hidden)]
pub trait SealedSender: Sealed {}

impl Sealed for TreeSender {}
impl SealedSender for TreeSender {}

impl<S: SealedSender, P> Sealed for WithFallback<S, P> {}
impl<S: SealedSender, P> SealedSender for WithFallback<S, P> {}

impl<Tx, Rx, T> LayerBuilder<Tx, Process<Rx>, T>
where
    Rx: Processor,
{
    /// Configure the processor on the receiving end of the log channel.
    /// This is particularly useful for adding fallbacks.
    /// 
    /// # Examples
    ///
    /// Updating the receiver in a [`LayerBuilder`] generated by [`worker_task`].
    /// ```
    /// # use crate::tracing_forest::Processor;
    /// # #[tokio::main(flavor = "current_thread")]
    /// # async fn main() {
    /// tracing_forest::worker_task()
    ///     .map_receiver(|receiver| {
    ///         receiver
    ///             .set_writer(std::io::stderr)
    ///             .with_stderr_fallback()
    ///     })
    ///     .build()
    ///     .on(async {
    ///         // ...
    ///     })
    ///     .await;
    /// # }
    /// ```
    pub fn map_receiver<F, Rx2>(self, f: F) -> LayerBuilder<Tx, Process<Rx2>, T>
    where
        F: FnOnce(Rx) -> Rx2,
        Rx2: Processor,
    {
        LayerBuilder {
            sender_processor: self.sender_processor,
            receiver_kind: Process(f(self.receiver_kind.0)),
            receiver: self.receiver,
            tag: self.tag,
            is_global: self.is_global,
        }
    }
}

impl<Tx, Rx, T> LayerBuilder<Tx, Rx, T>
where
    Tx: Processor + SealedSender,
    T: TagParser,
{
    /// Configure the processer within the subscriber that sends log trees to
    /// a processing task.
    /// 
    /// # Examples
    ///
    /// Updating the sender in a [`LayerBuilder`].
    /// ```
    /// # use crate::tracing_forest::processor::Processor;
    /// # #[tokio::main(flavor = "current_thread")]
    /// # async fn main() {
    /// tracing_forest::worker_task()
    ///     .map_sender(|sender| sender.with_stderr_fallback())
    ///     .build()
    ///     .on(async {
    ///         // ...
    ///     })
    ///     .await;
    /// # }
    /// ```
    /// 
    /// Since dropping the sender half would make the receiver task useless, this
    /// method uses traits to enforce at compile time that the function returns
    /// some derivative of the sender. Currently, the only accepted wrapping is
    /// through adding a fallback.
    /// ```compile_fail
    /// # use tracing_forest::processor::Printer;
    /// # #[tokio::main(flavor = "current_thread")]
    /// # async fn main() {
    /// tracing_forest::worker_task()
    ///     .map_sender(|_sender| {
    ///         // Some variation of the sender isn't returned, so this won't compile.
    ///         Printer::default()
    ///     })
    ///     .build()
    ///     .on(async {
    ///         // ...
    ///     })
    ///     .await;
    /// # }
    /// ```
    pub fn map_sender<F, Tx2>(self, f: F) -> LayerBuilder<Tx2, Rx, T>
    where
        F: FnOnce(Tx) -> Tx2,
        Tx2: Processor + SealedSender,
    {
        LayerBuilder {
            sender_processor: f(self.sender_processor),
            receiver_kind: self.receiver_kind,
            receiver: self.receiver,
            tag: self.tag,
            is_global: self.is_global,

        }
    }

    /// Set the tag parser.
    pub fn set_tag<T2>(self, tag: T2) -> LayerBuilder<Tx, Rx, T2>
    where
        T2: TagParser,
    {
        LayerBuilder {
            sender_processor: self.sender_processor,
            receiver_kind: self.receiver_kind,
            receiver: self.receiver,
            tag,
            is_global: self.is_global,
        }
    }

    /// Set whether or not the subscriber should be set globally.
    pub fn set_global(mut self, is_global: bool) -> Self {
        self.is_global = is_global;
        self
    }

    /// Finishes the `ForestLayer` by calling a function to build a `Subscriber`,
    /// and returns it as a [`Runtime`].
    /// 
    /// # Examples
    /// 
    /// Composing a `Subscriber` with multiple layers:
    /// ```
    /// use tracing_subscriber::{filter::LevelFilter, layer::SubscriberExt, Registry};
    /// use tracing_forest::ForestLayer;
    /// 
    /// #[tokio::main]
    /// async fn main() {
    ///     tracing_forest::worker_task()
    ///         .build_with(|layer: ForestLayer<_, _>| {
    ///             Registry::default()
    ///                 .with(layer)
    ///                 .with(LevelFilter::INFO)
    ///         })
    ///         .on(async {
    ///             // ...
    ///         })
    ///         .await;
    /// }
    /// ```
    pub fn build_with<F, S>(self, f: F) -> Runtime<S, Rx>
    where
        F: FnOnce(ForestLayer<Tx, T>) -> S,
        S: Subscriber,
    {
        let layer = ForestLayer::new(self.sender_processor, self.tag);
        let subscriber = f(layer);

        Runtime {
            subscriber,
            kind: self.receiver_kind,
            receiver: self.receiver,
            is_global: self.is_global,
        }
    }

    /// Finishes the `ForestLayer` by composing it into a [`Registry`], and
    /// returns it as a [`Runtime`].
    /// 
    /// # Examples
    /// 
    /// ```
    /// #[tokio::main]
    /// async fn main() {
    ///     tracing_forest::worker_task()
    ///         .build()
    ///         .on(async {
    ///             // ...
    ///         })
    ///         .await;
    /// }
    /// ```
    pub fn build(self) -> Runtime<Layered<ForestLayer<Tx, T>, Registry>, Rx> {
        self.build_with(|layer| layer.with_subscriber(Registry::default()))
    }
}

/// Execute a `Future` in the context of a subscriber with a `ForestLayer`.
/// 
/// This type is returned by [`build`] and [`build_with`].
/// 
/// [`build`]: LayerBuilder::build
/// [`build_with`]: LayerBuilder::build_with
pub struct Runtime<S, K> {
    subscriber: S,
    kind: K, // either `Process<_>` or `Capture`
    receiver: UnboundedReceiver<Tree>,
    is_global: bool,
}

impl<S, P> Runtime<S, Process<P>>
where
    S: Subscriber + Send + Sync,
    P: Processor + Send,
{
    /// Execute a future in the context of the configured subscriber.
    pub async fn on(self, f: impl Future<Output = ()>) {
        let (shutdown_tx, mut shutdown_rx) = oneshot::channel();
        let processor = self.kind.0;
        let mut receiver = self.receiver;

        let handle = tokio::spawn(async move {
            loop {
                tokio::select! {
                    Some(tree) = receiver.recv() => {
                        processor.process(tree).unwrap_or_else(fail::processing_error);
                    }
                    Ok(()) = &mut shutdown_rx => break,
                }
            }

            receiver.close();

            // Drain any remaining logs in the channel buffer.
            while let Some(tree) = receiver.recv().await {
                processor.process(tree).unwrap_or_else(fail::processing_error);
            }
        });

        let _guard = if self.is_global {
            tracing::subscriber::set_global_default(self.subscriber)
                .expect("global default already set");
            None
        } else {
            Some(tracing::subscriber::set_default(self.subscriber))
        };

        f.await;

        shutdown_tx.send(()).expect("Shutdown signal couldn't send, this is a bug.");

        handle.await.expect("Failed to join the writing task, this is a bug.");
    }
}

impl<S> Runtime<S, Capture>
where
    S: Subscriber + Send + Sync,
{
    /// Execute a future in the context of the configured subscriber, and return
    /// a `Vec<Tree>` of generated logs.
    pub async fn on<F>(mut self, f: F) -> Vec<Tree>
    where
        F: Future<Output = ()>,
    {
        {
            let _guard = if self.is_global {
                tracing::subscriber::set_global_default(self.subscriber)
                    .expect("global default already set");
                None
            } else {
                Some(tracing::subscriber::set_default(self.subscriber))
            };

            f.await;
        }

        self.receiver.close();

        let mut logs = Vec::with_capacity(32);

        while let Some(tree) = self.receiver.recv().await {
            logs.push(tree);
        }

        logs
    }
}
